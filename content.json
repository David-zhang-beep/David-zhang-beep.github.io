{"meta":{"title":"Hexo","subtitle":"","description":"","author":"David","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"C++异常处理","slug":"C-异常处理","date":"2020-08-22T00:41:43.000Z","updated":"2020-08-22T06:39:39.741Z","comments":true,"path":"2020/08/22/C-异常处理/","link":"","permalink":"http://yoursite.com/2020/08/22/C-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/","excerpt":"","text":"C++标准异常类1 基类 exception 12345678class exception &#123;public: exception() throw(); exception(const exception&amp; rhs) throw(); exception&amp; operator=(const exception&amp; rhs) throw(); virtual ~exception() throw(); virtual const char *what() const throw();&#125;; 2 下设两个派生异常类 12345678910111213141516171819202122232425262728logic_erro // 报告程序的逻辑错误，可在程序执行前被检测到. //再次派生 domain_error //报告违反了前置条件 invalid_argument // 指出函数的一个无效参数 length_error //指出有一个产生超过NPOS长度的对象的企图（NPOS为size_t的最大可表现值 out_of_range //报告参数越界 bad_cast //在运行时类型识别中有一个无效的dynamic_cast表达式 bad_typeid //报告在表达式typeid(*p)中有一个空指针P runtime_erro // 报告程序运行时的错误，只有在运行的时候才能检测到. //再次派生 range_error // 报告违反了后置条件 overflow_error //报告一个算术溢出 bad_alloc // 报告一个存储分配错误 3 智能指针如何解决内存泄漏 现有如下程序： 123456789void processAdoptions(istream&amp; dataSource)&#123; while(dataSource) &#123; ALA *pa = readALA(dataSource); //得到下一个动物 pa-&gt;processAdoption(); //处理收容动物 delete pa; //删除readALA返回的对象 &#125; &#125; 如果pa-&gt;processAdoption抛出了一个异常，processAdoption没有捕获异常，异常会向调用者传递，该语句后的语句将被跳过，pa将不被删除，从而导致内存泄漏。 解决方法 1：try catch 12345678910111213141516171819void processAdoptions(istream&amp; dataSource)&#123; while(dataSource) &#123; ALA *pa = readALA(dataSource); try &#123; pa-&gt;processAdoption(); &#125; catch(...) &#123; // 捕获所有异常 delete pa; // 避免内存泄漏 // 当异常抛出时 throw; // 传送异常给调用者 &#125; delete pa; // 避免资源泄漏 &#125; // 当没有异常抛出时&#125; 这样操作出现了重复清除的代码。 解决方法2 ：智能指针 先看智能指针autoptr源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110template&lt;class _Ty&gt; class auto_ptr &#123; // wrap an object pointer to ensure destructionpublic: typedef _Ty element_type; explicit auto_ptr(_Ty * _Ptr = nullptr) noexcept : _Myptr(_Ptr) &#123; // construct from object pointer &#125; auto_ptr(auto_ptr&amp; _Right) noexcept : _Myptr(_Right.release()) &#123; // construct by assuming pointer from _Right auto_ptr &#125; auto_ptr(auto_ptr_ref&lt;_Ty&gt; _Right) noexcept &#123; // construct by assuming pointer from _Right auto_ptr_ref _Ty * _Ptr = _Right._Ref; _Right._Ref = nullptr; // release old _Myptr = _Ptr; // reset this &#125; template&lt;class _Other&gt; operator auto_ptr&lt;_Other&gt;() noexcept &#123; // convert to compatible auto_ptr return (auto_ptr&lt;_Other&gt;(*this)); &#125; template&lt;class _Other&gt; operator auto_ptr_ref&lt;_Other&gt;() noexcept &#123; // convert to compatible auto_ptr_ref _Other * _Cvtptr = _Myptr; // test implicit conversion auto_ptr_ref&lt;_Other&gt; _Ans(_Cvtptr); _Myptr = nullptr; // pass ownership to auto_ptr_ref return (_Ans); &#125; template&lt;class _Other&gt; auto_ptr&amp; operator=(auto_ptr&lt;_Other&gt;&amp; _Right) noexcept &#123; // assign compatible _Right (assume pointer) reset(_Right.release()); return (*this); &#125; template&lt;class _Other&gt; auto_ptr(auto_ptr&lt;_Other&gt;&amp; _Right) noexcept : _Myptr(_Right.release()) &#123; // construct by assuming pointer from _Right &#125; auto_ptr&amp; operator=(auto_ptr&amp; _Right) noexcept &#123; // assign compatible _Right (assume pointer) reset(_Right.release()); return (*this); &#125; auto_ptr&amp; operator=(auto_ptr_ref&lt;_Ty&gt; _Right) noexcept &#123; // assign compatible _Right._Ref (assume pointer) _Ty * _Ptr = _Right._Ref; _Right._Ref = 0; // release old reset(_Ptr); // set new return (*this); &#125; ~auto_ptr() noexcept &#123; // destroy the object delete _Myptr; &#125; _NODISCARD _Ty&amp; operator*() const noexcept &#123; // return designated value #if _ITERATOR_DEBUG_LEVEL == 2 _STL_VERIFY(_Myptr, \"auto_ptr not dereferencable\"); #endif /* _ITERATOR_DEBUG_LEVEL == 2 */ return (*get()); &#125; _NODISCARD _Ty * operator-&gt;() const noexcept &#123; // return pointer to class object #if _ITERATOR_DEBUG_LEVEL == 2 _STL_VERIFY(_Myptr, \"auto_ptr not dereferencable\"); #endif /* _ITERATOR_DEBUG_LEVEL == 2 */ return (get()); &#125; _NODISCARD _Ty * get() const noexcept &#123; // return wrapped pointer return (_Myptr); &#125; _Ty * release() noexcept &#123; // return wrapped pointer and give up ownership _Ty * _Tmp = _Myptr; _Myptr = nullptr; return (_Tmp); &#125; void reset(_Ty * _Ptr = nullptr) &#123; // destroy designated object and store new pointer if (_Ptr != _Myptr) delete _Myptr; _Myptr = _Ptr; &#125;private: _Ty * _Myptr; // the wrapped object pointer &#125;; 隐藏在auto_ptr后的思想是： 用一个对象存储需要被自动释放的资源，然后依靠对象的析构函数来释放资源，这种思想不只是可以运用在指针上，还能用在其它资源的分配和释放上. 参数传递与抛出异常的区别： 1 C++规范要求被做为异常抛出的对象必须被复制.因此抛出异常运行速度比参数传递要慢. 2 传递参数时，如果是引用类型的形参则不用拷贝，但传异常即使是引用也是需要拷贝的. 3 异常捕获时一般不会出现隐式类型转换.但有两种特殊情况： ​ （1）继承类与基类的转换 ​ 一个用来捕获基类的catch子句也可以处理派生类类型的异常. ​ 例如在标准C++库（STL）定义的异常类层次中的诊断部分（diagnostics portion ）(参见Effective C++ 条款49). ​ 捕获runtime_errors异常的Catch子句可以捕获range_error类型和overflow_error类型的异常， ​ 可以接收根类exception异常的catch子句能捕获其任意派生类异常 ​ （2） 允许从一个类型化指针（typed pointer）转变成无类型指针（untyped pointer） 所以带有const void* 指针的catch子句能捕获任何类型的指针类型异常 4 传递参数和传递异常间最后一点差别是catch子句匹配顺序总是取决于它们在程序中出现的顺序. 对于指针类型的自定义对象在try catch语句中的行为分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;iostream&gt;#include&lt;vector&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;class Person &#123;public: string shengao; string tizhong; string xingbie;public: string getShengao() &#123; return shengao; &#125; void setShengao(string shengao) &#123; this-&gt;shengao= shengao; &#125; string getTizhong() &#123; return tizhong; &#125; void setTizhong(string tizhong) &#123; this-&gt;tizhong = tizhong; &#125; string getXingbie() &#123; return xingbie; &#125; void setXingbie(string xingbie) &#123; this-&gt;xingbie = xingbie; &#125; string mmp(string fuck) &#123; cout&lt;&lt;\"person : mmp\"&lt;&lt;endl; cout&lt;&lt;\"shengao:\"&lt;&lt;this-&gt;shengao&lt;&lt;endl; cout&lt;&lt;\"tizhong:\" &lt;&lt; this-&gt;tizhong&lt;&lt;endl; cout&lt;&lt;\"xingbie:\"&lt;&lt; this-&gt;xingbie&lt;&lt;endl; return fuck; &#125;&#125;;Person test() &#123; Person* person = new Person();try &#123; person-&gt;setShengao(\"172cm try block\"); cout&lt;&lt;\"try block\"&lt;&lt;endl; throw person; &#125; catch (Person* ) &#123; person-&gt;setTizhong(\"100kg\"); person-&gt;setXingbie(\"女\"); cout&lt;&lt;\"catch block\"&lt;&lt;endl; return *person; &#125; &#125;int main() &#123;test().mmp(\"fuck\");&#125; 最终结果： try block catch block person : mmp shengao :172cm try lock tizhong: 100kg xingbie:女","categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Linux常用命令","slug":"Linux常用命令","date":"2020-04-29T03:50:13.000Z","updated":"2020-04-29T08:55:10.414Z","comments":true,"path":"2020/04/29/Linux常用命令/","link":"","permalink":"http://yoursite.com/2020/04/29/Linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"常用指令 指令 功能 指令 功能 -ls 显示文件或目录 -l 列出文件详细信息 -a 列出当前目录下所有文件及目录，包括隐藏的 mkdir 创建目录 -p 创建目录，若无父目录，则创建parent cd 切换目录 touch 创建空文件 echo 创建带有内容的文件 cat 查看文件内容 cp 拷贝 mv 移动或重命名 rm 删除文件 -r 递归删除，可删除子目录及文件 -f 强制删除 find 在文件系统中搜索某文件 wc 统计文本中的行数，字数，字符数 grep 在文本文件中查找某个字符串 rmdir 删除空目录 tree 树形结构显示目录，需要安装tree包 pwd 显示当前目录 ln 创建链接文件 more，less 分页显示文本文件内容 head,tail 显示文件头，尾内容 ctrl+alt+F1 命令行全屏模式 系统管理命令 指令 功能 指令 功能 stat 显示指定文件的详细信息，比ls更详细 who 显示在线登录用户 whoami 显示当前操作用户 hostname 显示主机名 uname 显示系统信息 top 动态显示当前耗费资源最多进程信息 ps 显示瞬间进程状态ps -aux du 查看目录大小du -h /home 带有单位显示目录信息 df 查看磁盘大小 df -h带有单位显示磁盘信息 ifconfig 查看网络情况 ping 测试网络连通 netstat 显示网络状态信息 man 在手册中搜索帮助 clear 清屏 alias 对命令重命名如 alias showmeit = “ps-aux”,解除使用unalis kill 杀死进程，可以先使用ps或top命令查看进程的id，然后再用kill命令杀死进程 打包压缩相关命令 指令 功能 指令 功能 gzip 压缩文件，后文件有.zip扩展名 bzip2 创建和管理.bz2格式的压缩包 tar 打包压缩：-c 归档文件；-x解压缩文件;-z gzip压缩文件；-j bzip2压缩文件；-v 显示压缩或解压缩过程；-f 使用档名 例： tar -cvf /home/abc.tar /home/abc 只打包，不压缩 tar -zcvf /home/abc.tar.gz /home/abc 打包，并用 gzip 压缩 tar -jcvf /home/abc.tar.bz2 /home/abc 打包，并用 bzip2 压缩 tar -jxvf /home/abc.tar.bz2 /home/abc 解压缩 关机/重启机器 指令 功能 指令 功能 -r 关机重启 -h 关机不重启 now 立刻关机 halt 关机 reboot 重启 Linux软件包管理DPKG (Debian Package)管理工具软件包名以.deb后缀。这种方法适合系统不能联网的情况下。 比如安装tree命令的安装包，先将tree.deb传到Linux系统中。再使用如下命令安装。 sudo dpkg -i tree_1.5.3-1_i386.deb 安装软件 sudo dpkg -r tree 卸载软件 注：将tree.deb传到Linux系统中，有多种方式。VMwareTool，使用挂载方式；使用winSCP工具等； APT（Advanced Packaging Tool）高级软件工具这种方法适合系统能够连接互联网的情况。 依然以tree为例 sudo apt-get install tree 安装tree sudo apt-get remove tree 卸载tree sudo apt-get update 更新软件 sudo apt-get upgrade 将.rpm文件转为.deb文件 .rpm为RedHat使用的软件格式。在Ubuntu下不能直接使用，所以需要转换一下。 sudo alien abc.rpm vim 使用vim三种模式：命令模式、插入模式、编辑模式。使用ESC或i或：来切换模式。 指令 功能 指令 功能 :q 退出 :q! 强制退出 :wq 保存并退出 :set number 显示行号 :set nonumber 隐蔽行号 /apache 在文档中查找apache，按n跳到下一个，shift+n上一个 yyp 复制光标所在行，并粘贴 h,j,k,l 左移一个字符，下一行,上一行,右移一个字符 用户及用户组管理 指令 功能 指令 功能 /etc/passwd 存储用户账号 /etc/group 存储组账号 /etc/shadow 存储用户账号的密码 /etc/gshadow 存储用户组账号的密码 useradd 用户名 userdel 用户名 adduser 用户名 groupadd 组名 groupdel 组名 passwd root 给root设置密码 /etc/profile 系统环境变量 bash_profile 用户环境变量 .bashrc 用户环境变量 su user 切换用户，加载配置文件.bashrc su - user 切换用户，加载配置文件/etc/profile ，加载bash_profile 原文链接：https://blog.csdn.net/qq_40910541/article/details/80686362","categories":[],"tags":[{"name":"Linux 操作指令","slug":"Linux-操作指令","permalink":"http://yoursite.com/tags/Linux-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/"}]},{"title":"青客空间来了！","slug":"青客空间来了！","date":"2020-04-20T13:56:15.000Z","updated":"2020-04-20T14:54:04.055Z","comments":true,"path":"2020/04/20/青客空间来了！/","link":"","permalink":"http://yoursite.com/2020/04/20/%E9%9D%92%E5%AE%A2%E7%A9%BA%E9%97%B4%E6%9D%A5%E4%BA%86%EF%BC%81/","excerpt":"","text":"因何而来作为一名程序初学者，输入和输出是学习技术的不可或缺的两个要素。学习技术不能只停留在学进去，还要讲出来，同大家交流，这样才能真正转化为自己的知识。为了能和广大技术萌新们进行交流，传递新鲜的学习经验，笔者创建了青客空间微信公众号。 有何内容在公众号里我们会定期发送基于C++语言的数据结构与算法的学习经验。另外还会普及一些互联网招聘的经验和常见面试问题。如果青客们有任何相关的问题，可以及时提问，笔者会知无不言。 加入我们","categories":[],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"算法刷题-回溯算法","slug":"算法刷题-回溯算法","date":"2020-03-06T13:03:47.000Z","updated":"2020-04-22T02:20:09.153Z","comments":true,"path":"2020/03/06/算法刷题-回溯算法/","link":"","permalink":"http://yoursite.com/2020/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"总结​ 在排列中寻找一种或全部符合模式的情况均可以用回溯算法来解决。在考虑问题的过程中，如果模式简单则直接进行条件判断，如果模式较为复杂则化繁为简，从部分着手降低问题复杂度，最终采用部分匹配指标代替整体指标。下面的题目是典型的复杂模式匹配问题，从整体出发匹配比较复杂，但最终转化为了部分匹配问题。 题目描述小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌14张牌中有2张相同数字的牌，称为雀头。除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如：1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 输入例子11 1 1 2 2 2 5 5 5 6 6 6 9 输出例子19 例子说明1可以组成1,2,6,7的4个刻子和9的雀头 输入例子21 1 1 1 2 2 3 3 5 6 7 8 9 输出例子24 7 例子说明2用1做雀头，组123,123,567或456,789的四个顺子 输入例子31 1 1 2 2 2 3 3 3 5 7 7 9 输出例子30 例子说明3来任何牌都无法和牌 思路和牌问题：整体是否和牌，采用回溯算法+子问题转换，具体思路就是让前12张牌满足要求，剩下的2张牌如果是雀头即和牌。","text":"总结​ 在排列中寻找一种或全部符合模式的情况均可以用回溯算法来解决。在考虑问题的过程中，如果模式简单则直接进行条件判断，如果模式较为复杂则化繁为简，从部分着手降低问题复杂度，最终采用部分匹配指标代替整体指标。下面的题目是典型的复杂模式匹配问题，从整体出发匹配比较复杂，但最终转化为了部分匹配问题。 题目描述小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌14张牌中有2张相同数字的牌，称为雀头。除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如：1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 输入例子11 1 1 2 2 2 5 5 5 6 6 6 9 输出例子19 例子说明1可以组成1,2,6,7的4个刻子和9的雀头 输入例子21 1 1 1 2 2 3 3 5 6 7 8 9 输出例子24 7 例子说明2用1做雀头，组123,123,567或456,789的四个顺子 输入例子31 1 1 2 2 2 3 3 3 5 7 7 9 输出例子30 例子说明3来任何牌都无法和牌 思路和牌问题：整体是否和牌，采用回溯算法+子问题转换，具体思路就是让前12张牌满足要求，剩下的2张牌如果是雀头即和牌。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int total = 10;const int num = 13;void isWin(int cards[], int index, bool&amp; res) &#123; if (index == 12) &#123; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] == 2) &#123; res = true; return; &#125; &#125; &#125; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] &gt;= 3) &#123; cards[i] -= 3; isWin(cards, index + 3, res); cards[i] += 3; &#125; if (i + 2 &lt; total &amp;&amp; cards[i] &gt;= 1 &amp;&amp; cards[i + 1] &gt;= 1 &amp;&amp; cards[i + 2] &gt;= 1) &#123; cards[i] -= 1; cards[i + 1] -= 1; cards[i + 2] -= 1; isWin(cards, index + 3, res); cards[i] += 1; cards[i + 1] += 1; cards[i + 2] += 1; &#125; &#125;&#125;vector&lt;int&gt; getRes(int nums[]) &#123; vector&lt;int&gt; res; int cards[total] = &#123; 0 &#125;; for (int i = 0; i &lt; num; ++i) ++cards[nums[i]]; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] &lt; 4) &#123; ++cards[i]; bool found = false; isWin(cards, 0, found); if (found) res.push_back(i); --cards[i]; &#125; &#125; return res;&#125;int main()&#123; int nums[num];//添加输入元素 int i = 0; while (i &lt; num &amp;&amp; cin &gt;&gt; nums[i++]);//用数组来存储元素 vector&lt;int&gt; res = getRes(nums); if (res.size() == 0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; else &#123; for (int i : res) &#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; return 0; &#125;","categories":[],"tags":[{"name":"C++ 回溯算法 模式匹配 字节跳动2019春招研发部分编程题","slug":"C-回溯算法-模式匹配-字节跳动2019春招研发部分编程题","permalink":"http://yoursite.com/tags/C-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"Window程序设计（同步计时器）","slug":"Window程序设计（同步计时器）","date":"2020-02-27T07:11:25.000Z","updated":"2020-04-22T02:16:19.319Z","comments":true,"path":"2020/02/27/Window程序设计（同步计时器）/","link":"","permalink":"http://yoursite.com/2020/02/27/Window%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89/","excerpt":"前言在学习Window过程中，参考网上的案例练习的一个小项目，通过调用Window的API实现了与PC同步的时钟。这部分代码包含了大量的Window API，可以很好地熟悉Window的窗口命令函数的使用。当然也能够提高自己的代码理解能力。 实现效果","text":"前言在学习Window过程中，参考网上的案例练习的一个小项目，通过调用Window的API实现了与PC同步的时钟。这部分代码包含了大量的Window API，可以很好地熟悉Window的窗口命令函数的使用。当然也能够提高自己的代码理解能力。 实现效果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;Windows.h&gt;#define ID_TIMER 1LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void DisplayDigit(HDC, int);void DisplayTwoDigits(HDC ,int,BOOL);void DisplayColon(HDC);void DisplayTime(HDC, BOOL, BOOL);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; static TCHAR szAppName[] &#x3D; TEXT(&quot;MyWindows&quot;); HWND hwnd; MSG msg; WNDCLASS wndclass; wndclass.style &#x3D; CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc &#x3D; WndProc; wndclass.cbClsExtra &#x3D; 0; wndclass.cbWndExtra &#x3D; 0; wndclass.hInstance &#x3D; hInstance; wndclass.hIcon &#x3D; LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH); wndclass.lpszMenuName &#x3D; NULL; wndclass.lpszClassName &#x3D; szAppName; if (!RegisterClass(&amp;wndclass)) &#123; MessageBox(NULL, TEXT(&quot;这个程序要在Windows NT 才能执行！&quot;), szAppName, MB_ICONERROR); return 0; &#125; hwnd &#x3D; CreateWindow(szAppName, TEXT(&quot;张伟工作室&quot;), WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;void DisplayDigit(HDC hdc, int iNumber)&#123; static BOOL fSevenSegment[10][7] &#x3D; &#123; 1,1,1,0,1,1,1, &#x2F;&#x2F;0 0,0,1,0,0,1,0, &#x2F;&#x2F;1 1,0,1,1,1,0,1, &#x2F;&#x2F;2 1,0,1,1,0,1,1, &#x2F;&#x2F;3 0,1,1,1,0,1,0, &#x2F;&#x2F;4 1,1,0,1,0,1,1, &#x2F;&#x2F;5 1,1,0,1,1,1,1, &#x2F;&#x2F;6 1,0,1,0,0,1,0, &#x2F;&#x2F;7 1,1,1,1,1,1,1, &#x2F;&#x2F;8 1,1,1,1,0,1,1, &#x2F;&#x2F;9 &#125;; static POINT ptSegment[7][6] &#x3D; &#123; 7,6,11,2,31,2,35,6,31,10,11,10, &#x2F;&#x2F;A 6,7,10,11,10,31,6,35,2,31,2,11, &#x2F;&#x2F;B 36,7,40,11,40,31,36,35,32,31,32,11, &#x2F;&#x2F;c 7,36,11,32,31,32,35,36,31,40,11,40, &#x2F;&#x2F;D 6,37,10,41,10,61,6,65,2,61,2,41, &#x2F;&#x2F;E 36,37,40,41,40,61,36,65,32,61,32,41, &#x2F;&#x2F;F 7,66,11,62,31,62,35,66,31,70,11,70, &#x2F;&#x2F;G &#125;; int iSeg; for (iSeg &#x3D; 0; iSeg &lt; 7; iSeg++) &#123; if (fSevenSegment[iNumber][iSeg]) &#123; Polygon(hdc,ptSegment[iSeg],6); &#125; &#125;&#125;void DisplayTwoDigits(HDC hdc, int iNumber, BOOL fSuppress)&#x2F;&#x2F;显示两个数字&#123; if(!fSuppress || (iNumber &#x2F; 10 !&#x3D; 0)) &#123; DisplayDigit(hdc, iNumber &#x2F; 10); &#125; OffsetWindowOrgEx(hdc,-42,0,NULL); DisplayDigit(hdc,iNumber % 10); OffsetWindowOrgEx(hdc, -42, 0, NULL);&#125;void DisplayColon(HDC hdc)&#123; POINT ptColon[2][4] &#x3D; &#123; 2,21,6,17,10,21,6,25, 2,51,6,47,10,51,6,55 &#125;; Polygon(hdc,ptColon[0],4); Polygon(hdc,ptColon[1],4); OffsetWindowOrgEx(hdc,-12,0,NULL);&#125;void DisplayTime(HDC hdc, BOOL f24Hour, BOOL fSuppress)&#123; SYSTEMTIME st; GetLocalTime(&amp;st); if (f24Hour) &#123; DisplayTwoDigits(hdc,st.wHour,fSuppress); &#125; else &#123; DisplayTwoDigits(hdc,(st.wHour%&#x3D;12)? st.wHour:12,fSuppress); &#125; DisplayColon(hdc); DisplayTwoDigits(hdc,st.wMinute,FALSE); DisplayColon(hdc); DisplayTwoDigits(hdc,st.wSecond,FALSE);&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static BOOL f24Hour, fSuppress; static HBRUSH hBrushRed; static int cxClient, cyClient; HDC hdc; PAINTSTRUCT ps; RECT rect; TCHAR szBuffer[2]; switch (message) &#123; case WM_CREATE: hBrushRed &#x3D; CreateSolidBrush(RGB(255,0,0)); SetTimer(hwnd, ID_TIMER, 1000, NULL); case WM_SETTINGCHANGE: GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITIME, szBuffer, 2); f24Hour &#x3D; (szBuffer[0]&#x3D;&#x3D;&#39;1&#39;);&#x2F;&#x2F;0表示12小时，1表示24小时制 GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITIME, szBuffer, 2); fSuppress &#x3D; (szBuffer[0] &#x3D;&#x3D;&#39;0&#39;);&#x2F;&#x2F;0表示数字前面没有用0补位，1表示有 InvalidateRect(hwnd,NULL,TRUE); return 0; case WM_SIZE: cxClient &#x3D; LOWORD(lParam); cyClient &#x3D; HIWORD(lParam); return 0; case WM_TIMER: InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_PAINT: &#x2F;&#x2F;准备绘制 hdc &#x3D; BeginPaint(hwnd, &amp;ps); SetMapMode(hdc,MM_ISOTROPIC);&#x2F;&#x2F;同比例缩放用户界面 SetWindowExtEx(hdc,276,72,NULL); SetViewportExtEx(hdc,cxClient,cyClient,NULL); SetWindowOrgEx(hdc,138,36,NULL); SetViewportOrgEx(hdc,cxClient&#x2F;2,cyClient&#x2F;2,NULL); SelectObject(hdc,GetStockObject(NULL_PEN)); SelectObject(hdc,hBrushRed); DisplayTime(hdc,f24Hour,fSuppress); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: KillTimer(hwnd, ID_TIMER); PostQuitMessage(0); return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125; void CALLBACK TimerProc(HWND hwnd, UINT message, UINT iTimerID, DWORD dwTime) &#123; SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256))); InvalidateRect(hwnd, NULL, TRUE); &#125;全部","categories":[],"tags":[{"name":"Windows程序设计 C语言","slug":"Windows程序设计-C语言","permalink":"http://yoursite.com/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-C%E8%AF%AD%E8%A8%80/"}]},{"title":"数据结构与算法学习经验分享（一）基础篇","slug":"数据结构与算法学习经验分享（一）基础篇","date":"2020-02-26T04:22:57.768Z","updated":"2020-04-22T02:21:15.167Z","comments":true,"path":"2020/02/26/数据结构与算法学习经验分享（一）基础篇/","link":"","permalink":"http://yoursite.com/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"title: 数据结构与算法学习经验分享（一）基础篇date: 2020-02-26 12:22:57tags:C++/数据结构 基本数据结构1.STL stack(栈)相关函数： 函数 功能 s.empty() 判断栈是否为空 s.top() 返回栈顶 s.push(x) 将x添加至栈 s.pop() 弹出栈顶 s.size() 栈存储元素的个数","text":"title: 数据结构与算法学习经验分享（一）基础篇date: 2020-02-26 12:22:57tags:C++/数据结构 基本数据结构1.STL stack(栈)相关函数： 函数 功能 s.empty() 判断栈是否为空 s.top() 返回栈顶 s.push(x) 将x添加至栈 s.pop() 弹出栈顶 s.size() 栈存储元素的个数 2.STL queue(队列)相关函数： 函数 功能 Q.empty() 判断队列是否为空 Q.front() 返回队首元素 Q.back() 返回队尾元素 Q.pop() 弹出队首元素 Q.push(x) 将x添加至队列 Q.size() 队列存储元素的个数 3.二叉堆功能：维护一定数量的最大值或最小值（求中位数） 实现方法： std::priority queue&lt;int&gt; big_heap //默认最大堆 std::priority queue&lt;int, std::vector, std::greater&gt; small_heap //最小堆`` 4.STL set(集合)功能：主要用于查重 实现方法： std::set&lt;int&gt; test_set; //查询复杂度O(nlogn) 5.STL map(哈希)功能：主要用于建立映射关系 实现方法： std::map&lt;ListNode*,int&gt; node_map; //建立链表节点与整型数值的映射 6.STL sort(排序)功能：主要用于排序处理 实现方法： bool cmp(ListNode *a, ListNode *b){ return a-&gt;val &lt; b-&gt;val; } std::sort(vecor.begin(), vector.end(),cmp); //将数组元素从小到大排序 7.总结以上内容均为学习数据结构与算法过程中最常用到的数据结构。由于目前学习内容有限，只总结了部分内容，可供总结和查看。具体代码的练习还是得亲自做题巩固。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"C++","slug":"C","permalink":"http://yoursite.com/tags/C/"},{"name":"Linux 操作指令","slug":"Linux-操作指令","permalink":"http://yoursite.com/tags/Linux-%E6%93%8D%E4%BD%9C%E6%8C%87%E4%BB%A4/"},{"name":"微信公众号","slug":"微信公众号","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"C++ 回溯算法 模式匹配 字节跳动2019春招研发部分编程题","slug":"C-回溯算法-模式匹配-字节跳动2019春招研发部分编程题","permalink":"http://yoursite.com/tags/C-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"Windows程序设计 C语言","slug":"Windows程序设计-C语言","permalink":"http://yoursite.com/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-C%E8%AF%AD%E8%A8%80/"}]}