{"meta":{"title":"Hexo","subtitle":"","description":"","author":"David","url":"http://yoursite.com","root":"/"},"pages":[],"posts":[{"title":"青客空间来了！","slug":"青客空间来了！","date":"2020-04-20T13:56:15.000Z","updated":"2020-04-20T14:54:04.055Z","comments":true,"path":"2020/04/20/青客空间来了！/","link":"","permalink":"http://yoursite.com/2020/04/20/%E9%9D%92%E5%AE%A2%E7%A9%BA%E9%97%B4%E6%9D%A5%E4%BA%86%EF%BC%81/","excerpt":"","text":"因何而来作为一名程序初学者，输入和输出是学习技术的不可或缺的两个要素。学习技术不能只停留在学进去，还要讲出来，同大家交流，这样才能真正转化为自己的知识。为了能和广大技术萌新们进行交流，传递新鲜的学习经验，笔者创建了青客空间微信公众号。 有何内容在公众号里我们会定期发送基于C++语言的数据结构与算法的学习经验。另外还会普及一些互联网招聘的经验和常见面试问题。如果青客们有任何相关的问题，可以及时提问，笔者会知无不言。 加入我们","categories":[],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"}]},{"title":"算法刷题-回溯算法","slug":"算法刷题-回溯算法","date":"2020-03-06T13:03:47.000Z","updated":"2020-04-22T02:20:09.153Z","comments":true,"path":"2020/03/06/算法刷题-回溯算法/","link":"","permalink":"http://yoursite.com/2020/03/06/%E7%AE%97%E6%B3%95%E5%88%B7%E9%A2%98-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/","excerpt":"总结​ 在排列中寻找一种或全部符合模式的情况均可以用回溯算法来解决。在考虑问题的过程中，如果模式简单则直接进行条件判断，如果模式较为复杂则化繁为简，从部分着手降低问题复杂度，最终采用部分匹配指标代替整体指标。下面的题目是典型的复杂模式匹配问题，从整体出发匹配比较复杂，但最终转化为了部分匹配问题。 题目描述小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌14张牌中有2张相同数字的牌，称为雀头。除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如：1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 输入例子11 1 1 2 2 2 5 5 5 6 6 6 9 输出例子19 例子说明1可以组成1,2,6,7的4个刻子和9的雀头 输入例子21 1 1 1 2 2 3 3 5 6 7 8 9 输出例子24 7 例子说明2用1做雀头，组123,123,567或456,789的四个顺子 输入例子31 1 1 2 2 2 3 3 3 5 7 7 9 输出例子30 例子说明3来任何牌都无法和牌 思路和牌问题：整体是否和牌，采用回溯算法+子问题转换，具体思路就是让前12张牌满足要求，剩下的2张牌如果是雀头即和牌。","text":"总结​ 在排列中寻找一种或全部符合模式的情况均可以用回溯算法来解决。在考虑问题的过程中，如果模式简单则直接进行条件判断，如果模式较为复杂则化繁为简，从部分着手降低问题复杂度，最终采用部分匹配指标代替整体指标。下面的题目是典型的复杂模式匹配问题，从整体出发匹配比较复杂，但最终转化为了部分匹配问题。 题目描述小包最近迷上了一款叫做雀魂的麻将游戏，但是这个游戏规则太复杂，小包玩了几个月了还是输多赢少。于是生气的小包根据游戏简化了一下规则发明了一种新的麻将，只留下一种花色，并且去除了一些特殊和牌方式（例如七对子等），具体的规则如下： 总共有36张牌，每张牌是1~9。每个数字4张牌。你手里有其中的14张牌，如果这14张牌满足如下条件，即算作和牌14张牌中有2张相同数字的牌，称为雀头。除去上述2张牌，剩下12张牌可以组成4个顺子或刻子。顺子的意思是递增的连续3个数字牌（例如234,567等），刻子的意思是相同数字的3个数字牌（例如111,777） 例如：1 1 1 2 2 2 6 6 6 7 7 7 9 9 可以组成1,2,6,7的4个刻子和9的雀头，可以和牌1 1 1 1 2 2 3 3 5 6 7 7 8 9 用1做雀头，组123,123,567,789的四个顺子，可以和牌1 1 1 2 2 2 3 3 3 5 6 7 7 9 无论用1 2 3 7哪个做雀头，都无法组成和牌的条件。 现在，小包从36张牌中抽取了13张牌，他想知道在剩下的23张牌中，再取一张牌，取到哪几种数字牌可以和牌。 输入描述1输入只有一行，包含13个数字，用空格分隔，每个数字在1~9之间，数据保证同种数字最多出现4次。 输出描述1输出同样是一行，包含1个或以上的数字。代表他再取到哪些牌可以和牌。若满足条件的有多种牌，请按从小到大的顺序输出。若没有满足条件的牌，请输出一个数字0 输入例子11 1 1 2 2 2 5 5 5 6 6 6 9 输出例子19 例子说明1可以组成1,2,6,7的4个刻子和9的雀头 输入例子21 1 1 1 2 2 3 3 5 6 7 8 9 输出例子24 7 例子说明2用1做雀头，组123,123,567或456,789的四个顺子 输入例子31 1 1 2 2 2 3 3 3 5 7 7 9 输出例子30 例子说明3来任何牌都无法和牌 思路和牌问题：整体是否和牌，采用回溯算法+子问题转换，具体思路就是让前12张牌满足要求，剩下的2张牌如果是雀头即和牌。 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include&lt;stdio.h&gt;#include&lt;iostream&gt;#include&lt;vector&gt;using namespace std;const int total = 10;const int num = 13;void isWin(int cards[], int index, bool&amp; res) &#123; if (index == 12) &#123; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] == 2) &#123; res = true; return; &#125; &#125; &#125; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] &gt;= 3) &#123; cards[i] -= 3; isWin(cards, index + 3, res); cards[i] += 3; &#125; if (i + 2 &lt; total &amp;&amp; cards[i] &gt;= 1 &amp;&amp; cards[i + 1] &gt;= 1 &amp;&amp; cards[i + 2] &gt;= 1) &#123; cards[i] -= 1; cards[i + 1] -= 1; cards[i + 2] -= 1; isWin(cards, index + 3, res); cards[i] += 1; cards[i + 1] += 1; cards[i + 2] += 1; &#125; &#125;&#125;vector&lt;int&gt; getRes(int nums[]) &#123; vector&lt;int&gt; res; int cards[total] = &#123; 0 &#125;; for (int i = 0; i &lt; num; ++i) ++cards[nums[i]]; for (int i = 1; i &lt; total; ++i) &#123; if (cards[i] &lt; 4) &#123; ++cards[i]; bool found = false; isWin(cards, 0, found); if (found) res.push_back(i); --cards[i]; &#125; &#125; return res;&#125;int main()&#123; int nums[num];//添加输入元素 int i = 0; while (i &lt; num &amp;&amp; cin &gt;&gt; nums[i++]);//用数组来存储元素 vector&lt;int&gt; res = getRes(nums); if (res.size() == 0) &#123; cout &lt;&lt; 0 &lt;&lt; endl; &#125; else &#123; for (int i : res) &#123; cout &lt;&lt; i &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; return 0; &#125;","categories":[],"tags":[{"name":"C++ 回溯算法 模式匹配 字节跳动2019春招研发部分编程题","slug":"C-回溯算法-模式匹配-字节跳动2019春招研发部分编程题","permalink":"http://yoursite.com/tags/C-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/"}]},{"title":"Window程序设计（同步计时器）","slug":"Window程序设计（同步计时器）","date":"2020-02-27T07:11:25.000Z","updated":"2020-04-22T02:16:19.319Z","comments":true,"path":"2020/02/27/Window程序设计（同步计时器）/","link":"","permalink":"http://yoursite.com/2020/02/27/Window%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%EF%BC%88%E5%90%8C%E6%AD%A5%E8%AE%A1%E6%97%B6%E5%99%A8%EF%BC%89/","excerpt":"前言在学习Window过程中，参考网上的案例练习的一个小项目，通过调用Window的API实现了与PC同步的时钟。这部分代码包含了大量的Window API，可以很好地熟悉Window的窗口命令函数的使用。当然也能够提高自己的代码理解能力。 实现效果","text":"前言在学习Window过程中，参考网上的案例练习的一个小项目，通过调用Window的API实现了与PC同步的时钟。这部分代码包含了大量的Window API，可以很好地熟悉Window的窗口命令函数的使用。当然也能够提高自己的代码理解能力。 实现效果 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192#include&lt;Windows.h&gt;#define ID_TIMER 1LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void DisplayDigit(HDC, int);void DisplayTwoDigits(HDC ,int,BOOL);void DisplayColon(HDC);void DisplayTime(HDC, BOOL, BOOL);int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, PSTR szCmdLine, int iCmdShow)&#123; static TCHAR szAppName[] &#x3D; TEXT(&quot;MyWindows&quot;); HWND hwnd; MSG msg; WNDCLASS wndclass; wndclass.style &#x3D; CS_HREDRAW | CS_VREDRAW; wndclass.lpfnWndProc &#x3D; WndProc; wndclass.cbClsExtra &#x3D; 0; wndclass.cbWndExtra &#x3D; 0; wndclass.hInstance &#x3D; hInstance; wndclass.hIcon &#x3D; LoadIcon(NULL, IDI_APPLICATION); wndclass.hCursor &#x3D; LoadCursor(NULL, IDC_ARROW); wndclass.hbrBackground &#x3D; (HBRUSH)GetStockObject(WHITE_BRUSH); wndclass.lpszMenuName &#x3D; NULL; wndclass.lpszClassName &#x3D; szAppName; if (!RegisterClass(&amp;wndclass)) &#123; MessageBox(NULL, TEXT(&quot;这个程序要在Windows NT 才能执行！&quot;), szAppName, MB_ICONERROR); return 0; &#125; hwnd &#x3D; CreateWindow(szAppName, TEXT(&quot;张伟工作室&quot;), WS_OVERLAPPEDWINDOW | WS_VSCROLL | WS_HSCROLL, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL, hInstance, NULL); ShowWindow(hwnd, iCmdShow); UpdateWindow(hwnd); while (GetMessage(&amp;msg, NULL, 0, 0)) &#123; TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); &#125; return msg.wParam;&#125;void DisplayDigit(HDC hdc, int iNumber)&#123; static BOOL fSevenSegment[10][7] &#x3D; &#123; 1,1,1,0,1,1,1, &#x2F;&#x2F;0 0,0,1,0,0,1,0, &#x2F;&#x2F;1 1,0,1,1,1,0,1, &#x2F;&#x2F;2 1,0,1,1,0,1,1, &#x2F;&#x2F;3 0,1,1,1,0,1,0, &#x2F;&#x2F;4 1,1,0,1,0,1,1, &#x2F;&#x2F;5 1,1,0,1,1,1,1, &#x2F;&#x2F;6 1,0,1,0,0,1,0, &#x2F;&#x2F;7 1,1,1,1,1,1,1, &#x2F;&#x2F;8 1,1,1,1,0,1,1, &#x2F;&#x2F;9 &#125;; static POINT ptSegment[7][6] &#x3D; &#123; 7,6,11,2,31,2,35,6,31,10,11,10, &#x2F;&#x2F;A 6,7,10,11,10,31,6,35,2,31,2,11, &#x2F;&#x2F;B 36,7,40,11,40,31,36,35,32,31,32,11, &#x2F;&#x2F;c 7,36,11,32,31,32,35,36,31,40,11,40, &#x2F;&#x2F;D 6,37,10,41,10,61,6,65,2,61,2,41, &#x2F;&#x2F;E 36,37,40,41,40,61,36,65,32,61,32,41, &#x2F;&#x2F;F 7,66,11,62,31,62,35,66,31,70,11,70, &#x2F;&#x2F;G &#125;; int iSeg; for (iSeg &#x3D; 0; iSeg &lt; 7; iSeg++) &#123; if (fSevenSegment[iNumber][iSeg]) &#123; Polygon(hdc,ptSegment[iSeg],6); &#125; &#125;&#125;void DisplayTwoDigits(HDC hdc, int iNumber, BOOL fSuppress)&#x2F;&#x2F;显示两个数字&#123; if(!fSuppress || (iNumber &#x2F; 10 !&#x3D; 0)) &#123; DisplayDigit(hdc, iNumber &#x2F; 10); &#125; OffsetWindowOrgEx(hdc,-42,0,NULL); DisplayDigit(hdc,iNumber % 10); OffsetWindowOrgEx(hdc, -42, 0, NULL);&#125;void DisplayColon(HDC hdc)&#123; POINT ptColon[2][4] &#x3D; &#123; 2,21,6,17,10,21,6,25, 2,51,6,47,10,51,6,55 &#125;; Polygon(hdc,ptColon[0],4); Polygon(hdc,ptColon[1],4); OffsetWindowOrgEx(hdc,-12,0,NULL);&#125;void DisplayTime(HDC hdc, BOOL f24Hour, BOOL fSuppress)&#123; SYSTEMTIME st; GetLocalTime(&amp;st); if (f24Hour) &#123; DisplayTwoDigits(hdc,st.wHour,fSuppress); &#125; else &#123; DisplayTwoDigits(hdc,(st.wHour%&#x3D;12)? st.wHour:12,fSuppress); &#125; DisplayColon(hdc); DisplayTwoDigits(hdc,st.wMinute,FALSE); DisplayColon(hdc); DisplayTwoDigits(hdc,st.wSecond,FALSE);&#125;LRESULT CALLBACK WndProc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)&#123; static BOOL f24Hour, fSuppress; static HBRUSH hBrushRed; static int cxClient, cyClient; HDC hdc; PAINTSTRUCT ps; RECT rect; TCHAR szBuffer[2]; switch (message) &#123; case WM_CREATE: hBrushRed &#x3D; CreateSolidBrush(RGB(255,0,0)); SetTimer(hwnd, ID_TIMER, 1000, NULL); case WM_SETTINGCHANGE: GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITIME, szBuffer, 2); f24Hour &#x3D; (szBuffer[0]&#x3D;&#x3D;&#39;1&#39;);&#x2F;&#x2F;0表示12小时，1表示24小时制 GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_ITIME, szBuffer, 2); fSuppress &#x3D; (szBuffer[0] &#x3D;&#x3D;&#39;0&#39;);&#x2F;&#x2F;0表示数字前面没有用0补位，1表示有 InvalidateRect(hwnd,NULL,TRUE); return 0; case WM_SIZE: cxClient &#x3D; LOWORD(lParam); cyClient &#x3D; HIWORD(lParam); return 0; case WM_TIMER: InvalidateRect(hwnd, NULL, TRUE); return 0; case WM_PAINT: &#x2F;&#x2F;准备绘制 hdc &#x3D; BeginPaint(hwnd, &amp;ps); SetMapMode(hdc,MM_ISOTROPIC);&#x2F;&#x2F;同比例缩放用户界面 SetWindowExtEx(hdc,276,72,NULL); SetViewportExtEx(hdc,cxClient,cyClient,NULL); SetWindowOrgEx(hdc,138,36,NULL); SetViewportOrgEx(hdc,cxClient&#x2F;2,cyClient&#x2F;2,NULL); SelectObject(hdc,GetStockObject(NULL_PEN)); SelectObject(hdc,hBrushRed); DisplayTime(hdc,f24Hour,fSuppress); EndPaint(hwnd, &amp;ps); return 0; case WM_DESTROY: KillTimer(hwnd, ID_TIMER); PostQuitMessage(0); return 0; &#125; return DefWindowProc(hwnd, message, wParam, lParam);&#125; void CALLBACK TimerProc(HWND hwnd, UINT message, UINT iTimerID, DWORD dwTime) &#123; SetClassLongPtr(hwnd, GCLP_HBRBACKGROUND, (LONG)CreateSolidBrush(RGB(rand() % 256, rand() % 256, rand() % 256))); InvalidateRect(hwnd, NULL, TRUE); &#125;全部","categories":[],"tags":[{"name":"Windows程序设计 C语言","slug":"Windows程序设计-C语言","permalink":"http://yoursite.com/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-C%E8%AF%AD%E8%A8%80/"}]},{"title":"数据结构与算法学习经验分享（一）基础篇","slug":"数据结构与算法学习经验分享（一）基础篇","date":"2020-02-26T04:22:57.768Z","updated":"2020-04-22T02:21:15.167Z","comments":true,"path":"2020/02/26/数据结构与算法学习经验分享（一）基础篇/","link":"","permalink":"http://yoursite.com/2020/02/26/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E7%A1%80%E7%AF%87/","excerpt":"title: 数据结构与算法学习经验分享（一）基础篇date: 2020-02-26 12:22:57tags:C++/数据结构 基本数据结构1.STL stack(栈)相关函数： 函数 功能 s.empty() 判断栈是否为空 s.top() 返回栈顶 s.push(x) 将x添加至栈 s.pop() 弹出栈顶 s.size() 栈存储元素的个数","text":"title: 数据结构与算法学习经验分享（一）基础篇date: 2020-02-26 12:22:57tags:C++/数据结构 基本数据结构1.STL stack(栈)相关函数： 函数 功能 s.empty() 判断栈是否为空 s.top() 返回栈顶 s.push(x) 将x添加至栈 s.pop() 弹出栈顶 s.size() 栈存储元素的个数 2.STL queue(队列)相关函数： 函数 功能 Q.empty() 判断队列是否为空 Q.front() 返回队首元素 Q.back() 返回队尾元素 Q.pop() 弹出队首元素 Q.push(x) 将x添加至队列 Q.size() 队列存储元素的个数 3.二叉堆功能：维护一定数量的最大值或最小值（求中位数） 实现方法： std::priority queue&lt;int&gt; big_heap //默认最大堆 std::priority queue&lt;int, std::vector, std::greater&gt; small_heap //最小堆`` 4.STL set(集合)功能：主要用于查重 实现方法： std::set&lt;int&gt; test_set; //查询复杂度O(nlogn) 5.STL map(哈希)功能：主要用于建立映射关系 实现方法： std::map&lt;ListNode*,int&gt; node_map; //建立链表节点与整型数值的映射 6.STL sort(排序)功能：主要用于排序处理 实现方法： bool cmp(ListNode *a, ListNode *b){ return a-&gt;val &lt; b-&gt;val; } std::sort(vecor.begin(), vector.end(),cmp); //将数组元素从小到大排序 7.总结以上内容均为学习数据结构与算法过程中最常用到的数据结构。由于目前学习内容有限，只总结了部分内容，可供总结和查看。具体代码的练习还是得亲自做题巩固。","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"微信公众号","slug":"微信公众号","permalink":"http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/"},{"name":"C++ 回溯算法 模式匹配 字节跳动2019春招研发部分编程题","slug":"C-回溯算法-模式匹配-字节跳动2019春招研发部分编程题","permalink":"http://yoursite.com/tags/C-%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95-%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D-%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A82019%E6%98%A5%E6%8B%9B%E7%A0%94%E5%8F%91%E9%83%A8%E5%88%86%E7%BC%96%E7%A8%8B%E9%A2%98/"},{"name":"Windows程序设计 C语言","slug":"Windows程序设计-C语言","permalink":"http://yoursite.com/tags/Windows%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1-C%E8%AF%AD%E8%A8%80/"}]}